//#region Variables in context

/**
* The object this script component is attached to
* 
*/
declare var object: WakingApp.Object;
//#endregion

//Global functions
/**
 * Finds an object in the scene by its name. The first object found will be returned. Returns null if no object is found.
 * 
 * @param {String} name The name of the object to find.
 * @returns {Object} The first found object with the specified name or null if no object was found.
 */
declare function findObjectByName(name: String): WakingApp.Object;
/**
 * Returns the intersection point between a ray casted from the center of the screen to the plane generated by the SLAM tracker, useful for placing objects in SLAM type projects. 
 * On the Editor, this function returns the intersection point between the mouse cursor and a plane placed and the center of the world pointing towards (0,1,0).
 * 
 * @returns {Vector3} 
 */
declare function getIntersectionPointSLAM(): WakingApp.Vector3;
/**
 * Returns the current SLAM tracking state. Possible values : 'none', 'low' and 'normal'.
 * 
 * @returns {String} 
 */
declare function getTrackingStateSLAM(): String;


//#region Static Classes

declare enum MaterialType {
    video,
    diffuse,
    pbr
}
declare enum LightType {
    directional,
    spot,
    point
}
declare enum Anchor {
	center,
	topLeft,
	top,
	topRight,
	right,
	bottomRight,
	bottom,
	bottomLeft,
	left
}

declare enum Pivot {
	center,
	topLeft,
	top,
	topRight,
	right,
	bottomRight,
	bottom,
	bottomLeft,
	left
}

declare enum Space {
	world,
	local
}

declare var Vector2: {
    prototype: WakingApp.Vector2;
    new(): WakingApp.Vector2;
	new(vec: WakingApp.Vector2): WakingApp.Vector2;
    new(x: Number, y: Number): WakingApp.Vector2;


    //Static Vector2 functions

    /**
     * Returns a dot product of vec1 & vec2.
     * 
     * @param {Vector2} vec1
     * @param {Vector2} vec2
     * @returns {Number}
     */
    dot(vec1: WakingApp.Vector2, vec2: WakingApp.Vector2): Number;

    /**
     * Returns a new Vector2 representing the linear interpolation between vec1 and vec2, by t which is a value between 0 and 1.
     * 
     * @param {Vector2} from 
     * @param {Vector2} to 
     * @param {Number} t 
     * @returns {Vector2} 
     */
    lerp(from: WakingApp.Vector2, to: WakingApp.Vector2, t: Number): WakingApp.Vector2;
    /**
     * Returns a new Vector2 which is the result of adding vec1 and vec2.
     * 
     * @param {Vector2} vec1 
     * @param {Vector2} vec2 
     * @returns {Vector2} 
     */
    add(vec1: WakingApp.Vector2, vec2: WakingApp.Vector2): WakingApp.Vector2;
    /**
     * Returns a new Vector2 which is the result of subtracting vec1 by vec2.
     * 
     * @param {Vector2} vec1 
     * @param {Vector2} vec2 
     * @returns {Vector2} 
     */
    subtract(vec1: WakingApp.Vector2, vec2: WakingApp.Vector2): WakingApp.Vector2;
    /**
     * Returns a new Vector2 which is the result of multiplying vec1 by vec2.
     * 
     * @param {Vector2} vec1 
     * @param {Vector2} vec2 
     * @returns {Vector2} 
     */
    multiply(vec1: WakingApp.Vector2, vec2: WakingApp.Vector2): WakingApp.Vector2;
    /**
     * Returns a new Vector2 which is the result of multiplying vec by a scalar.
     * 
     * @param {Vector2} vec 
     * @param {Number} scalar 
     * @returns {Vector2} 
     */
    multiply(vec: WakingApp.Vector2, scalar: Number): WakingApp.Vector2;
    /**
     * Returns a new Vector2 which is the result of dividing vec by a scalar.
     * 
     * @param {Vector2} vec 
     * @param {Number} scalar 
     * @returns {Vector2} 
     */
    divide(vec: WakingApp.Vector2, scalar: Number): WakingApp.Vector2;
	
	/**
     * Returns the distance between two vectors.
     * 
     * @param {Vector2} vec 
     * @param {Vector2} vec2 
     * @returns {Number} 
     */
    distance(vec: WakingApp.Vector2, vec2: WakingApp.Vector2): Number;
}

declare var Vector3: {
    prototype: WakingApp.Vector3;
    new(): WakingApp.Vector3;
	new(vec: WakingApp.Vector3): WakingApp.Vector3;
    new(x: Number, y: Number, z: Number): WakingApp.Vector3;


    //Static Vector3 functions

    /**
     * Returns a dot product of vec1 & vec2.
     * 
     * @param {Vector3} vec1
     * @param {Vector3} vec2
     * @returns {Number}
     */
    dot(vec1: WakingApp.Vector3, vec2: WakingApp.Vector3): Number;
    /**
     * Returns a cross product of vec1 & vec2.
     * 
     * @param {Vector3} vec1 
     * @param {Vector3} vec2 
     * @returns {Number} 
     */
    cross(vec1: WakingApp.Vector3, vec2: WakingApp.Vector3): Number;
    /**
     * Returns a new Vector3 representing the linear interpolation between vec1 and vec2, by t which is a value between 0 and 1.
     * 
     * @param {Vector3} from 
     * @param {Vector3} to 
     * @param {Number} t 
     * @returns {Vector3} 
     */
    lerp(from: WakingApp.Vector3, to: WakingApp.Vector3, t: Number): WakingApp.Vector3;
    /**
     * Returns a new Vector3 which is the result of adding vec1 and vec2.
     * 
     * @param {Vector3} vec1 
     * @param {Vector3} vec2 
     * @returns {Vector3} 
     */
    add(vec1: WakingApp.Vector3, vec2: WakingApp.Vector3): WakingApp.Vector3;
    /**
     * Returns a new Vector3 which is the result of subtracting vec1 by vec2.
     * 
     * @param {Vector3} vec1 
     * @param {Vector3} vec2 
     * @returns {Vector3} 
     */
    subtract(vec1: WakingApp.Vector3, vec2: WakingApp.Vector3): WakingApp.Vector3;
    /**
     * Returns a new Vector3 which is the result of multiplying vec1 by vec2.
     * 
     * @param {Vector3} vec1 
     * @param {Vector3} vec2 
     * @returns {Vector3} 
     */
    multiply(vec1: WakingApp.Vector3, vec2: WakingApp.Vector3): WakingApp.Vector3;
    /**
     * Returns a new Vector3 which is the result of multiplying vec by a scalar.
     * 
     * @param {Vector3} vec 
     * @param {Number} scalar 
     * @returns {Vector3} 
     */
    multiply(vec: WakingApp.Vector3, scalar: Number): WakingApp.Vector3;
    /**
     * Returns a new Vector3 which is the result of dividing vec by a scalar.
     * 
     * @param {Vector3} vec 
     * @param {Number} scalar 
     * @returns {Vector3} 
     */
    divide(vec: WakingApp.Vector3, scalar: Number): WakingApp.Vector3;
	
	/**
     * Returns the distance between two vectors.
     * 
     * @param {Vector3} vec 
     * @param {Vector3} vec2 
     * @returns {Number} 
     */
    distance(vec: WakingApp.Vector3, vec2: WakingApp.Vector3): Number;
	
    /**
     * Shorthand for 'new Vector3(0, 1, 0)' (read only).
     * 
     * @type {Vector3}
     */
    readonly up: WakingApp.Vector3;
    /**
     * Shorthand for 'new Vector3(1, 0, 0)' (read only).
     * 
     * @type {Vector3}
     */
    readonly right: WakingApp.Vector3;
    /**
     * Shorthand for 'new Vector3(0, 0, 1)' (read only).
     * 
     * @type {Vector3}
     */
    readonly forward: WakingApp.Vector3;
}

declare var Color: {
	prototype: WakingApp.Color;
    new(): WakingApp.Color;
	new(vec: WakingApp.Color): WakingApp.Color;
    new(r: Number, g: Number, b: Number, a: Number): WakingApp.Color;

    /**
     * Returns a new Color representing the linear interpolation between color1 and color2, by t which is a value between 0 and 1. 
     * 
     * @param {Color} color1 
     * @param {Color} color2 
     * @param {Number} time 
     * @returns {WakingApp.Color} 
     */
    lerp(color1: WakingApp.Color, color2: WakingApp.Color, time: Number): WakingApp.Color;
    /**
     * Returns a new Color which is the result of adding color1 and color2.
     * 
     * @param {Color} color1 
     * @param {Color} color2 
     * @returns {WakingApp.Color} 
     */
    add(color1: WakingApp.Color, color2: WakingApp.Color): WakingApp.Color;
    /**
     * Returns a new Color which is the result of subtracting color1 by color2.
     * 
     * @param {Color} color1 
     * @param {Color} color2 
     * @returns {WakingApp.Color} 
     */
    subtract(color1: WakingApp.Color, color2: WakingApp.Color): WakingApp.Color;
    /**
     * Returns a new Color which is the result of multiplying color1 by color2.
     * 
     * @param {Color} color1 
     * @param {Color} color2 
     * @returns {WakingApp.Color} 
     */
    multiply(color1: WakingApp.Color, color2: WakingApp.Color): WakingApp.Color;
    /**
     * Returns a new Color which is the result of multiplying a color by a scalar.
     * 
     * @param {Color} color
     * @param {Number} scalar 
     * @returns {WakingApp.Color}
     */
    multiply(color: WakingApp.Color, scalar: Number): WakingApp.Color;
    /**
     * Returns a new Color which is the result of dividing a color by a scalar.
     * 
     * @param {Color} color1 
     * @param {Number} scalar 
     * @returns {WakingApp.Color} 
     */
    divide(color: WakingApp.Color, scalar: Number): WakingApp.Color;
}

declare var Camera: {
    /**
     * The camera’s position in world space (Read only).
     * 
     * @type {Vector3}
     */
    readonly position: WakingApp.Vector3;
    /**
     * The camera’s rotation in world space, represented by euler angles (Read only).
     * 
     * @type {Vector3}
     */
    readonly rotation: WakingApp.Vector3;
    /**
     * The camera’s forward direction (Read only).
     * 
     * @type {Vector3}
     */
    readonly forward: WakingApp.Vector3;
    /**
     * The camera’s right direction (Read only).
     * 
     * @type {Vector3}
     */
    readonly right: WakingApp.Vector3;
    /**
     * The camera’s up direction (Read only).
     * 
     * @type {Vector3}
     */
    readonly up: WakingApp.Vector3;
	
	/**
	 * Returns the intersection point between a ray cast from the center of the screen to the plane generated by the SLAM tracker, useful for placing objects in SLAM type projects. 
	 * On the Editor, this function returns the intersection point between the mouse cursor and a plane placed and the center of the world pointing towards (0,1,0).
	 * 
	 * @returns {Vector3} 
	 */
	declare function getIntersectionPointSLAM(): WakingApp.Vector3;
	
		/**
	 * Returns the intersection rotation between a ray cast from the center of the screen to the plane generated by the SLAM tracker, useful for placing objects in SLAM type projects.  
	 * @returns {Vector3} 
	 */
	declare function getIntersectionRotationSLAM(): WakingApp.Vector3;
}
/**
 * Log class for writing messages to the console log (Editor) or the device log (mobile).
 * 
 */
declare var Log: {
    /**
     * Prints a message to the console log (Editor) or the device log (mobile).
     * 
     * @param {String} message 
     */
    printMessage(message: String): void;
    /**
     * Prints an error to the console log (Editor) or the device log (mobile).
     * 
     * @param {String} error 
     */
    printError(error: String): void;
}
//#endregion

/**
 * Class which contains application-wide utility functions
 * 
 */
declare var Application: {
    /**
     * Opens the url in a new page with the default browser.
     * 
     * @param {String} url 
     */
    openURL(url: String): void;
	
	    /**
     * Unloads the currently open scene and loads another scene that is part of the project.
     * 
     * @param {String} sceneName 
     */
    loadScene(sceneName: String): void;

}
//#endregion

/**
 * Class which grants access to read user input
 * 
 */
declare var Input: {
    /**
     * The number of currently active screen touches (mobile). On the Editor, the left mouse button will be considered as a single touch.
     * 
     * @type {Number}
     */
    readonly touchCount: Number;
}
//#endregion

declare namespace WakingApp {

    export interface Object {
        /**
         * The name of the object, as it appears in the editor.
         * 
         * @type {String}
         */
        name: String;
        /**
         * An id that is unique to this object (read only).
         * 
         * @type {Number}
         */
        readonly id: Number;
        /**
         * Weather the object is currently enabled.
         * 
         * @type {boolean}
         */
        enabled: boolean;
        /**
         * The transform component of this object (read only).
         * 
         * @type {Transform}
         */
        readonly transform: Transform;
        /**
         * 	The animation component of this object if it has one, null otherwise (read only).
         * 
         * @type {Animation}
         */
        readonly animation: Animation;
        /**
         * The audio component of this object if it has one, null otherwise (read only).
         * 
         * @type {Audio}
         */
        readonly audio: Audio;
        /**
         * The light component of this object if it has one, null otherwise (read only).
         * 
         * @type {Light}
         */
        readonly light: Light;
        /**
         * The mesh component of this object if it has one, null otherwise (read only).
         * 
         * @type {Mesh}
         */
        readonly mesh: Mesh;
		 /**
         * The button component of this object if it has one, null otherwise (read only).
         * 
         * @type {Mesh}
         */
        readonly button: Button;
		/**
         * The label component of this object if it has one, null otherwise (read only).
         * 
         * @type {Mesh}
         */
        readonly label: Label;
    }

    export interface Transform {
		/**
         * The parent object of this transform
         * 
         * @type {Object}
         */
		parent : WakingApp.Object;
        /**
         * The transform's position in world space
         * 
         * @type {Vector3}
         */
        position: WakingApp.Vector3;
        /**
         * The transform's position in local space
         * 
         * @type {Vector3}
         */
        localPosition: WakingApp.Vector3;
        /**
         * The transform’s scale in local space.
         * 
         * @type {Vector3}
         */
        localScale: WakingApp.Vector3;
        /**
         * The transform’s rotation in world space, represented by euler angles.
         * 
         * @type {Vector3}
         */
        rotation : WakingApp.Vector3;
        /**
         * The transform’s rotation in local space, represented by euler angles.
         * 
         * @type {Vector3}
         */
        localRotation: WakingApp.Vector3;
        /**
         * The number of children in the transform (read only).
         * 
         *
         * @type {Number}
         */
        readonly childCount: Number;
        /**
         * The Object which is the owner of this transform component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
        /**
         * The transform’s up direction (read only).
         * 
         * 
         * @type {Vector3}
         */
        readonly up: WakingApp.Vector3;
        /**
         * The transform’s right direction (read only).
         * 
         * 
         * @type {Vector3}
         */
        readonly right: WakingApp.Vector3;
        /**
         * The transform’s forward direction (read only).
         * 
         * 
         * @type {Vector3}
         */
        readonly forward: WakingApp.Vector3;
        /**
         * Rotates the transform by the specified degrees around the specified axis relative to the specified space.
         * 
         * @param {Number} degress 
         * @param {Vector3} axis 
		 * @param {Space} space 
         */
        rotate(degress: Number, axis: WakingApp.Vector3, space : Space = Space.world): void;
        /**
         * Rotates the transform so that its forward direction points towards the specified position.
         * 
         * @param {Vector3} position 
         */
        lookAt(position: WakingApp.Vector3): void;
        /**
         * Translates the transform in the specified direction, relative to the specified space.
         * 
         * @param {Vector3} direction 
		 * @param {Space} space 
         */
        translate(direction: WakingApp.Vector3, space : Space = Space.world): void;
        /**
         * Adds the specified childTransform as a child of this transform. This will remove childTransform from its current parent should it have one.
         * 
         * @param {Transform} childTransform 
         */
        addChild(childTransform: Transform): void;
        /**
         * Removes the specified childTransform from the Transform’s child list. You should save a reference for this Transform for accessing it afterwards.
         * 
         * @param {Transform} childTransform 
         */
        removeChild(childTransform: Transform): void;
        /**
         * Returns a child object by the specified name, or null if no child was found.
         * 
         * @param {String} name - The object's name to search for.
         * @param {Boolean} searchInChildren - Determines whether the search should be recursive.
         * @returns {Transform} 
         */
        getChildByName(name: String, searchInChildren: Boolean): WakingApp.Object;
        /**
         * Returns a child object by the specified index, or null if no child exists at that index.
         * 
         * @param {Number} index
         * @returns {Trasnform} 
         */
        getChildByIndex(index: Number): WakingApp.Object;
    }

    export interface Animation {
		
		/**
         * The Object which is the owner of this animation component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
        /**
         * Starts playing the animation.
         * 
         */
        play(): void;
        /**
         * Pauses the animation. Playing it again will pick it from where it was paused.
         * 
         */
        pause(): void;
        /**
         * Stops the animation, resetting it to its first frame.
         * 
         */
        stop(): void;
        /**
         * Whether the animation is currently playing or not.
         * 
         * @returns {boolean} true if the animation is being played, false otherwise
         */
        isPlaying(): boolean;
        /**
         * Returns an AnimationClip with the specified name or null if no clip is found.
         * 
         * @param {String} name 
         * @returns {Animationclip} 
         */
        getClipByName(name: String): Animationclip;
        /**
         * 	Returns an AnimationClip by the specified index.
         * 
         * @param {Number} index 
         * @returns {AnimationClip} 
         */
        getClipByIndex(index: Number): AnimationClip;
        /**
         * Determines whether the animation should loop on end, or not.
         * 
         * @type {boolean}
         */
        loop: boolean;
        /**
         * The current time in the AnimationClip. Runs from 0 to the ‘length’ property of the AnimationClip.
         * 
         * @type {Number}
         */
        time: Number;
		       /**
         * The current animation playing speed. Clamped between 0 and 2.
         * 
         * @type {Number}
         */
        playSpeed: Number;
        /**
         * The number of clips stored in the animation (Read only).
         * 
         * @type {Number}
         */
        readonly clipCount: Number;
        /**
         * The currently set animationClip.
         * 
         * @type {AnimationClip}
         */
        clip: AnimationClip;
    }

    export interface AnimationClip {
        /**
         * How long the clip runs for (in seconds) (Read only).
         * 
         * @type {Number}
         */
        readonly length: Number;
        /**
         * 	Holds the clip’s name (Read only).
         * 
         * @type {String}
         */
        readonly name: String;
    }
    export interface Audio {
		 /**
         * The Object which is the owner of this audio component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
        /**
         * Starts playing the audio clip.
         * 
         */
        play(): void;
        /**
         * Pauses the audio clip. Playing it again will pick it from where it was paused.
         * 
         */
        pause(): void;
        /**
         * Stops the audio clip, resetting it to the beginning.
         * 
         */
        stop(): void;
        /**
         * Whether the audio clip is currently playing or not.
         * 
         * @returns {boolean} true if the audio clip is being played, false otherwise.
         */
        isPlaying(): boolean;
        /**
         * Determines whether the audio should loop on end, or not.
         * 
         * @type {boolean}
         */
        loop: boolean;
        /**
         * Determines the volume of the audio clip. Clamped between 0 and 1.
         * 
         * @type {Number}
         */
        volume: Number;
        /**
         * Determines the pitch of the audio clip.
         * 
         * @type {Number}
         */
        pitch: Number;

    }

    export interface Light {
		        /**
         * The Object which is the owner of this light component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
        /**
         * Holds the light color property.
         * 
         * @type {Color}
         */
        color : WakingApp.Color;
        /**
         * Holds the light intensity property.
         * 
         * @type {Number}
         */
        intensity : Number;
        /**
         * Holds the light radius property.
         * 
         * @type {Number}
         */
        radius : Number;
        /**
         * Holds the light type.
         * 
         * @type {LightType}
         * @memberof Light
         */
        type : LightType;
    }
	
	export interface Button {
		 /**
         * The Object which is the owner of this buton component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
		 /**
         * A function which gets called whenever the button is pressed.
         * 
         * @type {Function}
         * @memberof Button
         */
		onPressed : Function
         /**
         * The button's anchor point.
         * 
         * @type {Anchor}
         * @memberof Button
         */
        anchor : Anchor;
		         /**
         * The button's pivot point.
         * 
         * @type {Pivot}
         * @memberof Button
         */
        pivot : Pivot;
		
		/**
         * Determines whether the button should be rendered.
         * 
         * @type {boolean}
		 * @memberof Button
         */
        visible: boolean;
		
		/**
         * Holds the text displayed on top of the button.
         * 
         * @type {String}
         * @memberof Button
         */
        text: String;
		
		 /**
         * Holds the button color property.
         * 
         * @type {Color}
         * @memberof Button
         */
        color: WakingApp.Color;
		
		/**
         * Holds the button text color property.
         * 
         * @type {Color}
         * @memberof Button
         */
        textColor: WakingApp.Color;
		
		/**
         * Holds the button border color property.
         * 
         * @type {Color}
         * @memberof Button
         */
        borderColor: WakingApp.Color;
		
				/**
         * Holds the button pressed color property.
         * 
         * @type {Color}
         * @memberof Button
         */
        pressedColor: WakingApp.Color;
		
		/**
         * Holds the button position relative to its anchor.
         * 
         * @type {Vector2}
         * @memberof Button
         */
        position: WakingApp.Vector2;
		
		/**
         * Holds the button size relative to the project's UI-preview resolution.
         * 
         * @type {Vector2}
         * @memberof Button
         */
        size: WakingApp.Vector2;
		
    }
	
	export interface Label {
		 /**
         * The Object which is the owner of this label component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;
		
         /**
         * The label's anchor point.
         * 
         * @type {Anchor}
         * @memberof Label
         */
        anchor : Anchor;
		         /**
         * The label's pivot point.
         * 
         * @type {Pivot}
         * @memberof Label
         */
        pivot : Pivot;
		
		/**
         * Determines whether the label should be rendered.
         * 
         * @type {boolean}
		 * @memberof Label
         */
        visible: boolean;
		
		/**
         * Holds the text displayed on top of the label.
         * 
         * @type {String}
         * @memberof Label
         */
        text: String;
				
		/**
         * Holds the label text color property.
         * 
         * @type {Color}
         * @memberof Label
         */
        textColor: WakingApp.Color;
				
		/**
         * Holds the label position relative to its anchor.
         * 
         * @type {Vector2}
         * @memberof Label
         */
        position: WakingApp.Vector2;
		
		/**
         * Holds the label size relative to the project's UI-preview resolution.
         * 
         * @type {Vector2}
         * @memberof Label
         */
        size: WakingApp.Vector2;
		
    }
	
    export interface Mesh {
		/**
         * The Object which is the owner of this mesh component (read only).
         * 
         * @type {Object}
         */
        readonly object: Object;

		/**
         * The material of this mesh if it has one, null otherwise (read only).
		 * The returned material returns as an instance of the correct material type.
         * 
         * @type {GenericMaterial}
         */
        readonly material: GenericMaterial;
    }

 export interface Vector2 {
        /**
         * The X component of this vector.
         * 
         * @type {Number}
         */
        x: Number;
        /**
         * The Y component of this vector.
         * 
         * @type {Number}
         */
        y: Number;

        /**
         * Normalize this vector, which causes it to become a 'unit vector' of length=1.
         * 
         */
        normalize(): void;
        /**
         * Add vec to this vector.
         * 
         */
        add(vec: WakingApp.Vector2): void;
        /**
         * Subtract vec from this vector.
         * 
         */
        subtract(vec: WakingApp.Vector2): void;
        /**
         * Multiply this vector by vec.
         * 
         */
        multiply(vec: WakingApp.Vector2): void;
        /**
         * Multiply this vector by a scalar.
         * 
         */
        multiply(scalar: Number): void;
        /**
         * Divide this vector by a scalar.
         * 
         */
        divide(scalar: Number): void;
        /**
        * A Vector2 which is a normalized (unit vector) representation of this vector (read only).
        * 
        * @type {Vector2}
        */
        readonly normalized: WakingApp.Vector2;
        /**
        * The Length of this vector (read only).
        * 
        * @type {Number}
        */
        readonly length: Number;
    }

    export interface Vector3 {
        /**
         * The X component of this vector.
         * 
         * @type {Number}
         */
        x: Number;
        /**
         * The Y component of this vector.
         * 
         * @type {Number}
         */
        y: Number;
        /**
         * The Z component of this vector.
         * 
         * @type {Number}
         */
        z: Number;

        /**
         * Normalize this vector, which causes it to become a 'unit vector' of length=1.
         * 
         */
        normalize(): void;
        /**
         * Add vec to this vector.
         * 
         */
        add(vec: WakingApp.Vector3): void;
        /**
         * Subtract vec from this vector.
         * 
         */
        subtract(vec: WakingApp.Vector3): void;
        /**
         * Multiply this vector by vec.
         * 
         */
        multiply(vec: WakingApp.Vector3): void;
        /**
         * Multiply this vector by a scalar.
         * 
         */
        multiply(scalar: Number): void;
        /**
         * Divide this vector by a scalar.
         * 
         */
        divide(scalar: Number): void;
        /**
        * A Vector3 which is a normalized (unit vector) representation of this vector (read only).
        * 
        * @type {Vector3}
        */
        readonly normalized: WakingApp.Vector3;
        /**
        * The Length of this vector (read only).
        * 
        * @type {Number}
        */
        readonly length: Number;
    }

    export interface Color {
        /**
         * Red component of the Color.
         * 
         * @type {Number}
         */
        r: Number;
        /**
         * Green component of the Color.
         * 
         * @type {Number}
         */
        g: Number;
        /**
         * Blue component of the Color.
         * 
         * @type {Number}
         */
        b: Number;
        /**
         * Alpha component of the Color.
         * 
         * @type {Number}
         */
        a: Number;
        /**
         * Add color to this color.
         * 
         * @param {Color} color 
         */
        add(color: WakingApp.Color): void;
        /**
         * Subtract color from this color.
         * 
         * @param {Color} color 
         */
        substract(color: WakingApp.Color): void;
        /**
         * Multiply this color by color.
         * 
         * @param {Color} color 
         */
        multiply(color: WakingApp.Color): void;
        /**
         * Multiply this color by a scalar.
         * 
         * @param {Number} scalar 
         */
        multiply(scalar: Number): void;
        /**
         * Divide this color by a scalar.
         * 
         * @param {Number} scalar
         */
        divide(scalar: Number): void;
    }

    export interface MaterialBase {
        /**
         * Holds the material diffuse color property.
         * 
         * @type {Color}
         * @memberof MaterialBase
         */
        diffuse: WakingApp.Color;
        /**
         * Holds the material type (Read only).
         * 
         * @type {MaterialType}
         * @memberof MaterialBase
         */
        readonly type: MaterialType;
        /**
         * Holds the material name (Read only).
         * 
         * @type {String}
         * @memberof MaterialBase
         */
        readonly name: String;
    }

    export interface DiffuseMaterial extends MaterialBase {
    }

    export interface VideoMaterial extends MaterialBase {
        /**
         * Starts playing the video.
         * 
         * @memberof VideoMaterial
         */
        playVideo(): void;
        /**
         * Pauses the video. Playing it again will pick it from where it was paused.
         * 
         * @memberof VideoMaterial
         */
        pauseVideo(): void;
        /**
         * Stops the video, resetting it to the beginning.
         * 
         * @memberof VideoMaterial
         */
        stopVideo(): void;
		/**
         * Whether the video is currently playing or not.
         * 
         * @returns {boolean} true if the video is being played, false otherwise.
         */
        isPlaying(): void;
		/**
         * Determines whether the video should loop on end, or not.
         * 
         * @type {boolean}
         */
        loop: boolean;
        /**
         * Determines the volume of the video clip. Clamped between 0 and 1.
         * 
         * @type {Number}
         */
        volume: Number;
    }

    export interface PBRMaterial extends MaterialBase {
        /**
         * Holds the material metallicness property.
         * 
         * @type {Number}
         * @memberof PBRMaterial
         */
        metallic: Number;
        /**
         * Holds the material roughness property.
         * 
         * @type {Number}
         * @memberof PBRMaterial
         */
        roughness: Number;
        /**
         * Holds the material emissive color property.
         * 
         * @type {Color}
         * @memberof PBRMaterial
         */
        emissive: WakingApp.Color;
        /**
         * Holds the material normal strength property.
         * 
         * @type {Number}
         * @memberof PBRMaterial
         */
        normalStrength: Number;
    }

    export interface GenericMaterial extends DiffuseMaterial, PBRMaterial, VideoMaterial {

    }
}